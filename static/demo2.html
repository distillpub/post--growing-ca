<!DOCTYPE html>
<meta charset="utf-8">

<title>Growing CA Demo 2</title>

<h1>Growing CA Demo 2</h1>

<p>Select target: 
    <span id="emoji_selector"></span>
</p>

<canvas id="c" width="512", height="512"></canvas><br>
<button onclick="benchmark()">Benchmark</button><br>
<pre id='log'>
</pre>

<script src="https://unpkg.com/twgl.js@4.14.2/dist/4.x/twgl.js"></script>
<script src="https://mrdoob.github.io/stats.js/build/stats.min.js"></script>
<script>
  "use strict";

  const sel = document.getElementById('emoji_selector');
  for (let c of 'ğŸ˜€ğŸ’¥ğŸ‘ğŸ¦ğŸ ğŸ¦‹ğŸğŸ•¸ğŸ¥¨ğŸ„') {
      sel.innerHTML += `<span>${c}</span>`;
  }


  function decodeArray(s, arrayType) {
    const data = atob(s);
    const buf = new Uint8Array(data.length);
    for (var i=0; i<data.length; ++i) {
      buf[i] = data.charCodeAt(i);
    }
    return new arrayType(buf.buffer);
  }

  const gl = document.getElementById("c").getContext("webgl");
  const ext = gl.getExtension('OES_texture_half_float');
  
  const vs_code = `
  attribute vec4 position;
  varying vec2 uv;
  void main() {
    uv = position.xy*0.5 + 0.5;
    gl_Position = position;
  }
  `
  const PREFIX = `
  precision highp float;
  
  struct BufferInfo {
    vec2 size;
    vec2 gridSize;
    float depth, packedDepth;
  };
  struct InputInfo {
    vec2 size;
    vec2 gridSize;
    float depth, packedDepth;
    sampler2D tex;
  };

  uniform BufferInfo u_output;

  const float PI = 3.14159265358979;
  
  const float _S = 127.0/255.0;
  vec4 _pack(vec4 v) {
    return atan(v)/PI + _S;
  }
  vec4 unpack(vec4 v) {
    return tan((v-_S)*PI);
  }

  vec2 getOutputXY() {
    return mod(gl_FragCoord.xy, u_output.size);
  }
  float getOutputChannel() {
    vec2 xy = floor(gl_FragCoord.xy/u_output.size);
    return xy.y*u_output.gridSize.x+xy.x;
  }

  vec4 sampleTensor(InputInfo tensor, vec2 pos, float ch) {
    vec2 p = pos/tensor.size;
    ch += 0.5;
    float tx = floor(mod(ch, tensor.gridSize.x));
    float ty = floor(ch / tensor.gridSize.x);
    p += vec2(tx, ty);
    return unpack(texture2D(tensor.tex, p/tensor.gridSize));
  }

  void setOutput(vec4 v) {
    gl_FragColor = _pack(v);
  }
  `;

  const initProgram = twgl.createProgramInfo(gl, [vs_code, `
  ${PREFIX}
  void main() {
    vec2 xy = getOutputXY();
    float ch = getOutputChannel();
    vec4 result = vec4(0.0);

    if (length(xy-0.5*(u_output.size-1.0))<1.0) { 
      result = vec4(vec3(float(ch>0.0)), 1.0);
    }
    setOutput(result);
  }
  `]);

  const perceptionProgram = twgl.createProgramInfo(gl, [vs_code, `
  ${PREFIX}
  uniform InputInfo u_input;

  void main() {
    vec2 xy = getOutputXY();
    float ch = getOutputChannel();
    float filterIdx = floor(ch/u_input.packedDepth);
    float inputCh = mod(ch, u_input.packedDepth);
    if (filterIdx == 0.0) {
      setOutput(sampleTensor(u_input, xy, inputCh));
    } else {
      vec2 dx = (filterIdx == 1.0) ? vec2(1.0, 0.0) : vec2(0.0, 1.0);
      vec2 dy = vec2(dx.y, dx.x);
      vec4 v = (sampleTensor(u_input, xy+dx, inputCh)-sampleTensor(u_input, xy-dx, inputCh))*2.0+
                sampleTensor(u_input, xy+dx+dy, inputCh)-sampleTensor(u_input, xy-dx+dy, inputCh)+
                sampleTensor(u_input, xy+dx-dy, inputCh)-sampleTensor(u_input, xy-dx-dy, inputCh);
      setOutput(v / 8.0);
    }
  }
  `]);

  const layerProgram = twgl.createProgramInfo(gl, [vs_code, `
  ${PREFIX}
  uniform InputInfo u_input;
  uniform sampler2D u_weightTex;

  uniform float u_relu;

  const float MAX_PACKED_DEPTH = 32.0;


  void main() {
    vec2 xy = getOutputXY();
    float ch = getOutputChannel();
    if (ch >= u_output.packedDepth)
        return;

    float dy = 1.0/(u_input.depth+1.0);
    vec2 p = vec2((ch+0.5)/u_output.packedDepth, dy*0.5);
    vec4 result = vec4(0.0);
    for (float i=0.0; i < MAX_PACKED_DEPTH; i+=1.0) {
        vec4 inVec = sampleTensor(u_input, xy, i);
        result += inVec.x * texture2D(u_weightTex, p); p.y += dy;
        result += inVec.y * texture2D(u_weightTex, p); p.y += dy;
        result += inVec.z * texture2D(u_weightTex, p); p.y += dy;
        result += inVec.w * texture2D(u_weightTex, p); p.y += dy;
        if (i+1.5>u_input.packedDepth) {
            break;
        }
    }
    result += texture2D(u_weightTex, p);  // bias
    setOutput(u_relu > 0.5 ? max(result, 0.0) : result);
  }
  `]);

  const dropoutProgram = twgl.createProgramInfo(gl, [vs_code, `
  ${PREFIX}
  uniform InputInfo u_input;
  uniform float u_seed, u_udpateProbability;
  varying vec2 uv;
  
  // "Hash without Sine" by David Hoskins (https://www.shadertoy.com/view/4djSRW)
  float hash13(vec3 p3) {
	p3  = fract(p3 * .1031);
    p3 += dot(p3, p3.yzx + 33.33);
    return fract((p3.x + p3.y) * p3.z);
  }

  void main() {
    vec2 xy = getOutputXY();
    vec4 result = unpack(texture2D(u_input.tex, uv));
    result *=  float(hash13(vec3(xy, u_seed)) <= u_udpateProbability);
    setOutput(result);
  }
  `]);

  const updateProgram = twgl.createProgramInfo(gl, [vs_code, `
  ${PREFIX}
  uniform InputInfo u_state;
  uniform InputInfo u_update;
  varying vec2 uv;

  void main() {
    vec2 xy = getOutputXY();
    float preMaxAlpha=0.0, postMaxAlpha=0.0;
    for (float y=-1.0; y<=1.0; ++y)
    for (float x=-1.0; x<=1.0; ++x) {
        float preAlpha = sampleTensor(u_state, xy+vec2(x, y), 0.0).a;
        float updateAlpha = sampleTensor(u_update, xy+vec2(x, y), 0.0).a;
        float postAlpha = preAlpha+updateAlpha;
        preMaxAlpha = max(preAlpha, preMaxAlpha);
        postMaxAlpha = max(postAlpha, postMaxAlpha);
    }
    if (min(preMaxAlpha, postMaxAlpha) < 0.1) {
        setOutput(vec4(0.0));
        return;
    }
    vec4 state = unpack(texture2D(u_state.tex, uv));
    vec4 update = unpack(texture2D(u_update.tex, uv));
    setOutput(state + update);
  }
  `]);

  const visProgram = twgl.createProgramInfo(gl, [vs_code, `
  ${PREFIX}
  precision mediump float;
  uniform InputInfo u_input;
  varying vec2 uv;
  void main() {
    vec2 xy = vec2(uv.x, 1.0-uv.y);
    xy *= u_input.size;
    vec4 rgba = sampleTensor(u_input, xy, 0.0);
    gl_FragColor = 1.0-rgba.a + rgba;
  }
  `]);
 
  const arrays = {
    position: [-1, -1, 0, 1, -1, 0, -1, 1, 0, -1, 1, 0, 1, -1, 0, 1, 1, 0],
  };
  const bufferInfo = twgl.createBufferInfoFromArrays(gl, arrays);

  function createTensor(h, w, depth) {
    const packedDepth = Math.ceil(depth / 4);
    const gridW = Math.ceil(Math.sqrt(packedDepth));
    const gridH = Math.floor((packedDepth+gridW-1)/gridW);
    const texW = w*gridW, texH = h*gridH;

    const attachments = [{minMag: gl.NEAREST}];
    const fbi = twgl.createFramebufferInfo(gl, attachments, texW, texH);
    const tex = fbi.attachments[0];
    return {fbi, w, h, depth, gridW, gridH, packedDepth, tex, _type: 'tensor'};
  }

  function setTensorUniforms(uniforms, name, tensor, isInput) {
    uniforms[name+'.size'] = [tensor.w, tensor.h];
    uniforms[name+'.gridSize'] = [tensor.gridW, tensor.gridH];
    uniforms[name+'.depth'] = tensor.depth;
    uniforms[name+'.packedDepth'] = tensor.packedDepth;
    if (isInput) {
      uniforms[name+'.tex'] = tensor.tex;
    }
  }

  function runLayer(program, output, inputs) {
    inputs = inputs || {};
    const uniforms = {};
    for (const name in inputs) {
      const val = inputs[name];
      if (val._type == 'tensor') {
        setTensorUniforms(uniforms, name, val, true);
      } else {
        uniforms[name] = val;
      }
    }
    setTensorUniforms(uniforms, 'u_output', output);
    //console.log(uniforms);

    twgl.bindFramebufferInfo(gl, output.fbi);
    gl.useProgram(program.program);
    twgl.setBuffersAndAttributes(gl, program, bufferInfo);
    twgl.setUniforms(program, uniforms);
    twgl.drawBufferInfo(gl, bufferInfo);
  }

  function createLayerTexture(params) {
    const src = params.data || decodeArray(params.data_b64, Uint16Array);
    return twgl.createTexture(gl, {
      minMag: gl.NEAREST, type: ext.HALF_FLOAT_OES, 
      width: params.out_ch/4, height: params.in_ch+1, src: src});
  }

  
  let layerTex1 = null;
  let layerTex2 = null;

  const GRAPH_URL = 'layers.js';
  fetch(GRAPH_URL).then(r=>r.json()).then(layers=>{
    console.log('loaded');
    layerTex1 = createLayerTexture(layers[0]);
    layerTex2 = createLayerTexture(layers[1]);
    requestAnimationFrame(render);
  });

  const CHANNEL_N = 16;
  const w = 128, h = 128;
  let stateBuf = createTensor(h, w, CHANNEL_N);
  let newStateBuf = createTensor(h, w, CHANNEL_N);
  const perceptionBuf = createTensor(h, w, CHANNEL_N*3);
  const hiddenBuf = createTensor(h, w, 128);
  const updateBuf = createTensor(h, w, CHANNEL_N);
  const maskedUpdateBuf = createTensor(h, w, CHANNEL_N);

  function fetchVec(buf, x, y) {
    twgl.bindFramebufferInfo(gl, buf.fbi);
    const w = buf.fbi.width, h = buf.fbi.width;
    const a = new Float32Array(h*w*4);
    gl.readPixels(0, 0, w, h, gl.RGBA, gl.FLOAT, a);
    const res = [];
    for (let i=0; i<buf.gridH; ++i)
    for (let j=0; j<buf.gridW; ++j)
    for (let k=0; k<4; ++k) {
        const ofs = ((i*buf.h+y)*w + j*buf.w + x)*4 + k; 
        res.push(a[ofs]);
        if (res.length == buf.depth)
            return res;
    }
    console.log('fetchVec out!');
  }



  function step() {
    if (!layerTex1 || !layerTex2)
      return;
    runLayer(perceptionProgram, perceptionBuf, {'u_input': stateBuf});
    runLayer(layerProgram, hiddenBuf, {'u_input': perceptionBuf, u_weightTex: layerTex1, u_relu: 1.0});
    runLayer(layerProgram, updateBuf, {'u_input': hiddenBuf, u_weightTex: layerTex2, u_relu: 0.0});
    runLayer(dropoutProgram, maskedUpdateBuf, {'u_input': updateBuf, 'u_seed': Math.random()*1000, 'u_udpateProbability': 0.5});
    runLayer(updateProgram, newStateBuf, {'u_state': stateBuf, 'u_update': maskedUpdateBuf});
    [stateBuf, newStateBuf] = [newStateBuf, stateBuf]
  }
  runLayer(initProgram, stateBuf);

  var stats = new Stats();
  document.body.appendChild( stats.dom );

  
  

  function render(time) {
    stats.begin();

    step();

    twgl.bindFramebufferInfo(gl);
    gl.useProgram(visProgram.program);
    twgl.setBuffersAndAttributes(gl, visProgram, bufferInfo);
    const uniforms = {}
    setTensorUniforms(uniforms, 'u_input', stateBuf, true);
    twgl.setUniforms(visProgram, uniforms);
    twgl.drawBufferInfo(gl, bufferInfo);

    gl.finish();
    stats.end();

    requestAnimationFrame(render);
  }


  function benchmark() {
    //const a = new Float32Array(4);
    const a = new Uint8Array(4);
    runLayer(initProgram, stateBuf);
    for (let i=0; i<10; ++i)
      step();
    const stepN = 400;
    const start = Date.now();
    for (let i=0; i<stepN; ++i)
      step();
    twgl.bindFramebufferInfo(gl, stateBuf.fbi);
    gl.readPixels(32, 32, 1, 1, gl.RGBA, gl.UNSIGNED_BYTE, a);
    const dt = Date.now()-start;
    document.getElementById('log').innerHTML += 
      `${stepN} steps: ${(dt/stepN).toFixed(2)} ms/step, (${(1000.0/dt*stepN).toFixed(2)} step/sec)\n`;
  }

</script>
