<!DOCTYPE html>
<meta charset="utf-8">

<title>Growing CA Demo 2</title>

<h1>Growing CA Demo 2</h1>

<p>Select target:
  <span id="emojiSelector"></span>
</p>

<canvas id="c" width="512" , height="512" style="image-rendering: pixelated; "></canvas><br>
Show: <select id='visMode'></select>
<button id="resetButton">Reset</button>
<button id="benchmarkButton">Benchmark</button>
<br>
<pre id='log'>
</pre>

<script src="twgl.min.js"></script>
<script src="https://mrdoob.github.io/stats.js/build/stats.min.js"></script>
<script type="module">
  import { createDemo } from './demo.js'


  const canvas = document.getElementById("c");
  const gl = canvas.getContext("webgl");

  let demo;

  fetch('webgl_models/ğŸ˜€.json').then(r => r.json()).then(layers => {
    demo = createDemo(gl, layers);
    const sel = document.getElementById('visMode');
    for (const mode of demo.visModes) {
      sel.innerHTML += `<option value="${mode}">${mode}</option>`;
    }

    document.getElementById('resetButton').onclick = demo.reset;

    requestAnimationFrame(render);
  });

  const modelSel = document.getElementById('emojiSelector');
  for (let c of 'ğŸ˜€ğŸ’¥ğŸ‘ğŸ¦ğŸ ğŸ¦‹ğŸğŸ•¸ğŸ¥¨ğŸ„') {
    modelSel.innerHTML += `<span>${c}</span>`;
  }
  modelSel.onclick = async e => {
    if (!demo)
      return;
    const emoji = e.target.innerText;
    const url = `webgl_models/${emoji}.json`;
    const r = await fetch(url);
    const model = await r.json();
    demo.setWeights(model);
    demo.reset();
  }

  function getMousePos(e) {
    const x = Math.floor(e.offsetX / canvas.width * 128);
    const y = Math.floor(e.offsetY / canvas.height * 128);
    return [x, y];
  }

  let doubleClick = false;

  canvas.onmousedown = e => {
    e.preventDefault();
    if (!demo)
      return;
    const [x, y] = getMousePos(e);
    if (e.buttons == 1) {
      if (doubleClick) {
        demo.paint(x, y, 1, 'seed');
        doubleClick = false;
      } else {
        doubleClick = true;
        setTimeout(()=>{
          doubleClick = false;
        }, 300);
        demo.paint(x, y, 8, 'clear');
      }
    }
  }
  canvas.onmousemove = e => {
    e.preventDefault();
    if (!demo)
      return;
    const [x, y] = getMousePos(e);
    if (e.buttons == 1 && !e.shiftKey) {
      demo.paint(x, y, 8, 'clear');
    }
  }


  var stats = new Stats();
  document.body.appendChild(stats.dom);


  function render(time) {
    if (!demo)
      return;
    stats.begin();

    demo.step();
    twgl.bindFramebufferInfo(gl);
    const mode = document.getElementById("visMode").value;
    demo.draw(mode);

    stats.end();

    requestAnimationFrame(render);
  }


  function benchmark() {
    if (!demo)
      return;

    const stepN = 400;
    const start = Date.now();
    for (let i = 0; i < stepN; ++i)
      demo.step();
    demo.flush();
    const dt = Date.now() - start;
    document.getElementById('log').innerHTML +=
      `${stepN} steps: ${(dt / stepN).toFixed(2)} ms/step, (${(1000.0 / dt * stepN).toFixed(2)} step/sec)\n`;
  }

  document.getElementById('benchmarkButton').onclick = benchmark;

</script>